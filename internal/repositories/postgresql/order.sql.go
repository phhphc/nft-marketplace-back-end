// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: order.sql

package postgresql

import (
	"context"
	"database/sql"
)

const insertOrder = `-- name: InsertOrder :exec
INSERT INTO "orders" ("order_hash", "offerer","recipient", "zone", "order_type", "zone_hash", "salt", "start_time", "end_time",
                      "signature", "is_validated", "is_cancelled", "is_fulfilled")
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
`

type InsertOrderParams struct {
	OrderHash   string
	Offerer     string
	Recipient   sql.NullString
	Zone        string
	OrderType   sql.NullInt32
	ZoneHash    string
	Salt        sql.NullString
	StartTime   sql.NullString
	EndTime     sql.NullString
	Signature   sql.NullString
	IsValidated bool
	IsCancelled bool
	IsFulfilled bool
}

func (q *Queries) InsertOrder(ctx context.Context, arg InsertOrderParams) error {
	_, err := q.db.ExecContext(ctx, insertOrder,
		arg.OrderHash,
		arg.Offerer,
		arg.Recipient,
		arg.Zone,
		arg.OrderType,
		arg.ZoneHash,
		arg.Salt,
		arg.StartTime,
		arg.EndTime,
		arg.Signature,
		arg.IsValidated,
		arg.IsCancelled,
		arg.IsFulfilled,
	)
	return err
}

const insertOrderConsiderationItem = `-- name: InsertOrderConsiderationItem :exec
INSERT INTO "consideration_items" ("order_hash", "item_type", "token", "identifier","amount", "start_amount", "end_amount",
                                   "recipient")
VALUES ($1, $2, $3, $4, $5, $6, $7,$8)
`

type InsertOrderConsiderationItemParams struct {
	OrderHash   string
	ItemType    int32
	Token       string
	Identifier  string
	Amount      sql.NullString
	StartAmount sql.NullString
	EndAmount   sql.NullString
	Recipient   string
}

func (q *Queries) InsertOrderConsiderationItem(ctx context.Context, arg InsertOrderConsiderationItemParams) error {
	_, err := q.db.ExecContext(ctx, insertOrderConsiderationItem,
		arg.OrderHash,
		arg.ItemType,
		arg.Token,
		arg.Identifier,
		arg.Amount,
		arg.StartAmount,
		arg.EndAmount,
		arg.Recipient,
	)
	return err
}

const insertOrderOfferItem = `-- name: InsertOrderOfferItem :exec
INSERT INTO "offer_items" ("order_hash", "item_type", "token", "identifier","amount", "start_amount", "end_amount")
VALUES ($1, $2, $3, $4, $5, $6,$7)
`

type InsertOrderOfferItemParams struct {
	OrderHash   string
	ItemType    int32
	Token       string
	Identifier  string
	Amount      sql.NullString
	StartAmount sql.NullString
	EndAmount   sql.NullString
}

func (q *Queries) InsertOrderOfferItem(ctx context.Context, arg InsertOrderOfferItemParams) error {
	_, err := q.db.ExecContext(ctx, insertOrderOfferItem,
		arg.OrderHash,
		arg.ItemType,
		arg.Token,
		arg.Identifier,
		arg.Amount,
		arg.StartAmount,
		arg.EndAmount,
	)
	return err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
UPDATE "orders"
SET
    "is_validated" = COALESCE($1, "is_validated"),
    "is_cancelled" = COALESCE($2, "is_cancelled"),
    "is_fulfilled" = COALESCE($3, "is_fulfilled")
WHERE "order_hash" = $4
RETURNING "order_hash"
`

type UpdateOrderStatusParams struct {
	IsValidated sql.NullBool
	IsCancelled sql.NullBool
	IsFulfilled sql.NullBool
	OrderHash   string
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (string, error) {
	row := q.db.QueryRowContext(ctx, updateOrderStatus,
		arg.IsValidated,
		arg.IsCancelled,
		arg.IsFulfilled,
		arg.OrderHash,
	)
	var order_hash string
	err := row.Scan(&order_hash)
	return order_hash, err
}
