// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: event.sql

package postgresql

import (
	"context"
	"database/sql"
)

const getEvent = `-- name: GetEvent :many
SELECT e.name, e.token, e.token_id, e.quantity, e.price, e.from, e.to, e.date, e.link
FROM "events" e
WHERE (e.name ILIKE $1 OR $1 IS NULL)
AND (e.token ILIKE $2 OR $2 IS NULL)
AND (e.token_id ILIKE $3 OR $3 IS NULL)
AND (e.from ILIKE $4 OR $4 IS NULL)
AND (e.to ILIKE $5 OR $5 IS NULL)
`

type GetEventParams struct {
	Name    sql.NullString
	Token   sql.NullString
	TokenID sql.NullString
	From    sql.NullString
	To      sql.NullString
}

type GetEventRow struct {
	Name     string
	Token    string
	TokenID  string
	Quantity sql.NullInt64
	Price    sql.NullString
	From     string
	To       sql.NullString
	Date     sql.NullTime
	Link     sql.NullString
}

func (q *Queries) GetEvent(ctx context.Context, arg GetEventParams) ([]GetEventRow, error) {
	rows, err := q.db.QueryContext(ctx, getEvent,
		arg.Name,
		arg.Token,
		arg.TokenID,
		arg.From,
		arg.To,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventRow{}
	for rows.Next() {
		var i GetEventRow
		if err := rows.Scan(
			&i.Name,
			&i.Token,
			&i.TokenID,
			&i.Quantity,
			&i.Price,
			&i.From,
			&i.To,
			&i.Date,
			&i.Link,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertEvent = `-- name: InsertEvent :one
INSERT INTO "events" ("name", "token", "token_id", "quantity", "price", "from", "to", "link")
VALUES ($1,$2,$3,$4,$5,$6,$7,$8)
RETURNING id, name, token, token_id, quantity, price, "from", "to", date, link
`

type InsertEventParams struct {
	Name     string
	Token    string
	TokenID  string
	Quantity sql.NullInt64
	Price    sql.NullString
	From     string
	To       sql.NullString
	Link     sql.NullString
}

func (q *Queries) InsertEvent(ctx context.Context, arg InsertEventParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, insertEvent,
		arg.Name,
		arg.Token,
		arg.TokenID,
		arg.Quantity,
		arg.Price,
		arg.From,
		arg.To,
		arg.Link,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Token,
		&i.TokenID,
		&i.Quantity,
		&i.Price,
		&i.From,
		&i.To,
		&i.Date,
		&i.Link,
	)
	return i, err
}
