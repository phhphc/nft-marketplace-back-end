// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: notification-read.sql

package gen

import (
	"context"
	"database/sql"
)

const getNotification = `-- name: GetNotification :many
SELECT n.is_viewed, n.info, n.event_name, n.order_hash, n.address,
    e.token, e.token_id, e.quantity, e.type, e.price, e.from, e.to, e.date,
    nft.owner,
    COALESCE(nft.metadata ->> 'image', '')::VARCHAR AS nft_image,
	COALESCE(nft.metadata ->> 'name', '')::VARCHAR AS nft_name
FROM "notifications" n
JOIN "events" e ON n.event_name = e.name AND n.order_hash = e.order_hash
JOIN "nfts" nft ON e.token = nft.token AND e.token_id = CAST(nft.identifier AS varchar(78))
WHERE (n.address = $1 OR $1 IS NULL)
AND (n.is_viewed = $2 OR $2 IS NULL)
`

type GetNotificationParams struct {
	Address  sql.NullString
	IsViewed sql.NullBool
}

type GetNotificationRow struct {
	IsViewed  sql.NullBool
	Info      string
	EventName string
	OrderHash string
	Address   string
	Token     string
	TokenID   string
	Quantity  sql.NullInt32
	Type      sql.NullString
	Price     sql.NullString
	From      string
	To        sql.NullString
	Date      sql.NullTime
	Owner     string
	NftImage  string
	NftName   string
}

func (q *Queries) GetNotification(ctx context.Context, arg GetNotificationParams) ([]GetNotificationRow, error) {
	rows, err := q.query(ctx, q.getNotificationStmt, getNotification, arg.Address, arg.IsViewed)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNotificationRow{}
	for rows.Next() {
		var i GetNotificationRow
		if err := rows.Scan(
			&i.IsViewed,
			&i.Info,
			&i.EventName,
			&i.OrderHash,
			&i.Address,
			&i.Token,
			&i.TokenID,
			&i.Quantity,
			&i.Type,
			&i.Price,
			&i.From,
			&i.To,
			&i.Date,
			&i.Owner,
			&i.NftImage,
			&i.NftName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
