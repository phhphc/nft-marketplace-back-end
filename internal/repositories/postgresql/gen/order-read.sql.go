// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: order-read.sql

package gen

import (
	"context"
	"database/sql"
	"encoding/json"
)

const getExpiredOrder = `-- name: GetExpiredOrder :many
SELECT DISTINCT e.name, o.order_hash, o.end_time, o.is_cancelled, o.is_invalid, o.offerer
FROM events e
         JOIN orders o ON e.order_hash = o.order_hash
WHERE (e.name = 'listing' OR e.name = 'offer')
  AND o.is_cancelled = false
  AND o.is_invalid = false
  AND o.end_time < $1
`

type GetExpiredOrderRow struct {
	Name        string
	OrderHash   string
	EndTime     sql.NullString
	IsCancelled bool
	IsInvalid   bool
	Offerer     string
}

func (q *Queries) GetExpiredOrder(ctx context.Context, now sql.NullString) ([]GetExpiredOrderRow, error) {
	rows, err := q.query(ctx, q.getExpiredOrderStmt, getExpiredOrder, now)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetExpiredOrderRow{}
	for rows.Next() {
		var i GetExpiredOrderRow
		if err := rows.Scan(
			&i.Name,
			&i.OrderHash,
			&i.EndTime,
			&i.IsCancelled,
			&i.IsInvalid,
			&i.Offerer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrder = `-- name: GetOrder :many
SELECT json_build_object(
               'order_hash', o.order_hash,
               'offerer', o.offerer,
               'signature', o.signature,
               'start_time', o.start_time::VARCHAR,
               'end_time', o.end_time::VARCHAR,
               'salt', o.salt,
               'status', json_build_object(
                       'is_fulfilled', o.is_fulfilled,
                       'is_cancelled', o.is_cancelled,
                       'is_invalid', o.is_invalid
                   ),
               'offer', (SELECT json_agg(
                                        json_build_object(
                                                'item_type', offer.item_type,
                                                'token', offer.token,
                                                'identifier', offer.identifier::VARCHAR,
                                                'start_amount', offer.start_amount::VARCHAR,
                                                'end_amount', offer.end_amount::VARCHAR
                                            )
                                    )
                         FROM offer_items offer
                         WHERE o.order_hash = offer.order_hash),
               'consideration', (SELECT json_agg(
                                                json_build_object(
                                                        'item_type', cons.item_type,
                                                        'token', cons.token,
                                                        'identifier', cons.identifier::VARCHAR,
                                                        'start_amount', cons.start_amount::VARCHAR,
                                                        'end_amount', cons.end_amount::VARCHAR,
                                                        'recipient', cons.recipient
                                                    )
                                            )
                                 FROM consideration_items cons
                                 WHERE o.order_hash = cons.order_hash)
           )
FROM orders o
WHERE o."order_hash" ILIKE COALESCE($1, o."order_hash")
  AND o.offerer ILIKE COALESCE($2, o.offerer)
  AND o."is_cancelled" = COALESCE($3, o."is_cancelled")
  AND o."is_fulfilled" = COALESCE($4, o."is_fulfilled")
  AND o."is_invalid" = COALESCE($5, o."is_invalid")
  AND o.order_hash IN (SELECT DISTINCT od.order_hash
                       FROM orders od
                                JOIN consideration_items ci on ci.order_hash = od.order_hash
                                JOIN offer_items oi on oi.order_hash = od.order_hash
                       WHERE ci."token" ILIKE COALESCE($6, ci."token")
                         AND ci.identifier = COALESCE($7, ci.identifier)
                         AND oi.token ILIKE COALESCE($8, oi.token)
                         AND oi.identifier = COALESCE($9, oi.identifier))
`

type GetOrderParams struct {
	OrderHash               sql.NullString
	Offerer                 sql.NullString
	IsCancelled             sql.NullBool
	IsFulfilled             sql.NullBool
	IsInvalid               sql.NullBool
	ConsiderationToken      sql.NullString
	ConsiderationIdentifier sql.NullString
	OfferToken              sql.NullString
	OfferIdentifier         sql.NullString
}

func (q *Queries) GetOrder(ctx context.Context, arg GetOrderParams) ([]json.RawMessage, error) {
	rows, err := q.query(ctx, q.getOrderStmt, getOrder,
		arg.OrderHash,
		arg.Offerer,
		arg.IsCancelled,
		arg.IsFulfilled,
		arg.IsInvalid,
		arg.ConsiderationToken,
		arg.ConsiderationIdentifier,
		arg.OfferToken,
		arg.OfferIdentifier,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []json.RawMessage{}
	for rows.Next() {
		var json_build_object json.RawMessage
		if err := rows.Scan(&json_build_object); err != nil {
			return nil, err
		}
		items = append(items, json_build_object)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
