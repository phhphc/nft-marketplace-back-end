// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: nft.new.sql

package postgresql

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/tabbed/pqtype"
)

const getListValidNFT = `-- name: GetListValidNFT :many
SELECT n.token,
       n.identifier,
       n.owner,
       n.metadata,
       n.is_burned,
       n.is_hidden
FROM "nfts" n
WHERE n.is_burned = FALSE
  AND (n.token ILIKE $1 OR $1 IS NULL)
  AND (n.owner ILIKE $2 OR $2 IS NULL)
ORDER BY n.token ASC, n.identifier ASC
OFFSET $3 LIMIT $4
`

type GetListValidNFTParams struct {
	Token  sql.NullString
	Owner  sql.NullString
	Offset int32
	Limit  int32
}

type GetListValidNFTRow struct {
	Token      string
	Identifier string
	Owner      string
	Metadata   pqtype.NullRawMessage
	IsBurned   bool
	IsHidden   bool
}

func (q *Queries) GetListValidNFT(ctx context.Context, arg GetListValidNFTParams) ([]GetListValidNFTRow, error) {
	rows, err := q.db.QueryContext(ctx, getListValidNFT,
		arg.Token,
		arg.Owner,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetListValidNFTRow{}
	for rows.Next() {
		var i GetListValidNFTRow
		if err := rows.Scan(
			&i.Token,
			&i.Identifier,
			&i.Owner,
			&i.Metadata,
			&i.IsBurned,
			&i.IsHidden,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNFTValidConsiderations = `-- name: GetNFTValidConsiderations :many
SELECT selected_nft.block_number,
       selected_nft.token,
       selected_nft.identifier,
       selected_nft.owner,
       selected_nft.is_hidden,
       selected_nft.metadata ->> 'image'       AS image,
       selected_nft.metadata ->> 'name'        AS name,
       selected_nft.metadata ->> 'description' AS description,
       selected_nft.metadata                   AS metadata,
       ci.order_hash,
       ci.item_type,
       ci.start_amount                         AS start_price,
       ci.end_amount                           AS end_price,
       o.start_time                            AS start_time,
       o.end_time                              AS end_time
FROM (SELECT token, identifier, owner, metadata, is_burned, is_hidden, block_number, tx_index
      FROM nfts
      WHERE nfts.token ILIKE $1
        AND nfts.identifier = $2) selected_nft
         LEFT JOIN "offer_items" oi ON oi.token ILIKE selected_nft.token AND oi.identifier = selected_nft.identifier
         LEFT JOIN "consideration_items" ci ON ci.order_hash ILIKE oi.order_hash
         LEFT JOIN (SELECT order_hash, offerer, recipient, salt, start_time, end_time, signature, is_cancelled, is_validated, is_fulfilled, is_invalid
                    FROM orders
                    WHERE orders.is_fulfilled = FALSE
                      AND orders.is_cancelled = FALSE
                      AND orders.start_time <= round(EXTRACT(EPOCH FROM now()))
                      AND orders.end_time >= round(EXTRACT(EPOCH FROM now()))) o
                   ON oi.order_hash ILIKE o.order_hash
`

type GetNFTValidConsiderationsParams struct {
	Token      string
	Identifier string
}

type GetNFTValidConsiderationsRow struct {
	BlockNumber string
	Token       string
	Identifier  string
	Owner       string
	IsHidden    bool
	Image       interface{}
	Name        interface{}
	Description interface{}
	Metadata    pqtype.NullRawMessage
	OrderHash   sql.NullString
	ItemType    sql.NullInt32
	StartPrice  sql.NullString
	EndPrice    sql.NullString
	StartTime   sql.NullString
	EndTime     sql.NullString
}

func (q *Queries) GetNFTValidConsiderations(ctx context.Context, arg GetNFTValidConsiderationsParams) ([]GetNFTValidConsiderationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getNFTValidConsiderations, arg.Token, arg.Identifier)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNFTValidConsiderationsRow{}
	for rows.Next() {
		var i GetNFTValidConsiderationsRow
		if err := rows.Scan(
			&i.BlockNumber,
			&i.Token,
			&i.Identifier,
			&i.Owner,
			&i.IsHidden,
			&i.Image,
			&i.Name,
			&i.Description,
			&i.Metadata,
			&i.OrderHash,
			&i.ItemType,
			&i.StartPrice,
			&i.EndPrice,
			&i.StartTime,
			&i.EndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNftWithListing = `-- name: ListNftWithListing :many
SELECT json_build_object(
               'token', n.token,
               'identifier', n.identifier::VARCHAR,
               'owner', n.owner,
               'metadata', n.metadata,
               'is_hidden', n.is_hidden,
               'listing',
               (SELECT json_agg(
                               json_build_object(
                                       'order_hash', l.order_hash,
                                       'item_type', l.item_type,
                                       'start_time', l.start_time::VARCHAR,
                                       'end_time', l.end_time::VARCHAR,
                                       'start_price', l.start_price::VARCHAR,
                                       'end_price', l.end_price::VARCHAR
                                   )
                           )
                FROM (SELECT o.order_hash,
                             ci.item_type,
                             o.start_time         AS start_time,
                             o.end_time           AS end_time,
                             SUM(ci.start_amount) AS start_price,
                             SUM(ci.end_amount)   AS end_price
                      FROM orders o
                               JOIN offer_items oi on o.order_hash = oi.order_hash
                               JOIN consideration_items ci on o.order_hash = ci.order_hash
                      WHERE o.order_hash NOT IN (SELECT DISTINCT c.order_hash
                                                 FROM consideration_items c
                                                 WHERE c.item_type != $1)
                        AND o.is_fulfilled = FALSE
                        AND o.is_cancelled = FALSE
                        AND o.is_invalid = FALSE
                        AND o.start_time <= $2
                        AND o.end_time > $2
                        AND oi.token ILIKE n.token
                        AND oi.identifier = n.identifier
                      GROUP BY o.order_hash,
                               ci.item_type,
                               o.start_time,
                               o.end_time
                      LIMIT $3) as l)
           )
FROM nfts n
WHERE n."is_burned" = FALSE
  AND n."is_hidden" = COALESCE($4, n."is_hidden")
  AND n."owner" ILIKE COALESCE($5, n."owner")
  AND n."token" ILIKE COALESCE($6, n."token")
  AND n."identifier" = COALESCE($7, n."identifier")
GROUP BY n.token, n.identifier
LIMIT $9 OFFSET $8
`

type ListNftWithListingParams struct {
	ItemType     int32
	Now          sql.NullString
	LimitListing int32
	IsHidden     sql.NullBool
	Owner        sql.NullString
	Token        sql.NullString
	Identifier   sql.NullString
	OffsetNft    int32
	LimitNft     int32
}

func (q *Queries) ListNftWithListing(ctx context.Context, arg ListNftWithListingParams) ([]json.RawMessage, error) {
	rows, err := q.db.QueryContext(ctx, listNftWithListing,
		arg.ItemType,
		arg.Now,
		arg.LimitListing,
		arg.IsHidden,
		arg.Owner,
		arg.Token,
		arg.Identifier,
		arg.OffsetNft,
		arg.LimitNft,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []json.RawMessage{}
	for rows.Next() {
		var json_build_object json.RawMessage
		if err := rows.Scan(&json_build_object); err != nil {
			return nil, err
		}
		items = append(items, json_build_object)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertNFTV2 = `-- name: UpsertNFTV2 :exec
INSERT INTO "nfts" (token, identifier, owner, metadata, is_burned)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (token, identifier) DO UPDATE SET owner     = $3,
                                              metadata  = $4,
                                              is_burned = $5
WHERE nfts.block_number < $6
   OR (nfts.block_number = $6 AND nfts.tx_index < $7)
`

type UpsertNFTV2Params struct {
	Token       string
	Identifier  string
	Owner       string
	Metadata    pqtype.NullRawMessage
	IsBurned    bool
	BlockNumber string
	TxIndex     int64
}

func (q *Queries) UpsertNFTV2(ctx context.Context, arg UpsertNFTV2Params) error {
	_, err := q.db.ExecContext(ctx, upsertNFTV2,
		arg.Token,
		arg.Identifier,
		arg.Owner,
		arg.Metadata,
		arg.IsBurned,
		arg.BlockNumber,
		arg.TxIndex,
	)
	return err
}
