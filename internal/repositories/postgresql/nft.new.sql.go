// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: nft.new.sql

package postgresql

import (
	"context"
	"database/sql"

	"github.com/tabbed/pqtype"
)

const getListValidNft = `-- name: GetListValidNft :many
SELECT
    n.token, n.identifier, n.owner, n.token_uri, n.metadata, n.is_burned
FROM "nfts" n
WHERE
    n.is_burned = FALSE
  AND
    (n.token ILIKE $1 OR $1 IS NULL)
  AND
    (n.owner ILIKE $2 OR $2 IS NULL)
ORDER BY n.token ASC, n.identifier ASC
OFFSET $3
LIMIT $4
`

type GetListValidNftParams struct {
	Token  sql.NullString
	Owner  sql.NullString
	Offset int32
	Limit  int32
}

type GetListValidNftRow struct {
	Token      string
	Identifier string
	Owner      string
	TokenUri   sql.NullString
	Metadata   pqtype.NullRawMessage
	IsBurned   bool
}

func (q *Queries) GetListValidNft(ctx context.Context, arg GetListValidNftParams) ([]GetListValidNftRow, error) {
	rows, err := q.db.QueryContext(ctx, getListValidNft,
		arg.Token,
		arg.Owner,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetListValidNftRow{}
	for rows.Next() {
		var i GetListValidNftRow
		if err := rows.Scan(
			&i.Token,
			&i.Identifier,
			&i.Owner,
			&i.TokenUri,
			&i.Metadata,
			&i.IsBurned,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidNft = `-- name: GetValidNft :one
SELECT
    n.token, n.identifier, n.owner, n.token_uri, n.metadata, n.is_burned
FROM "nfts" n
WHERE
    n.is_burned = FALSE
  AND
    n.token = $1
  AND
    n.identifier = $2
`

type GetValidNftParams struct {
	Token      string
	Identifier string
}

type GetValidNftRow struct {
	Token      string
	Identifier string
	Owner      string
	TokenUri   sql.NullString
	Metadata   pqtype.NullRawMessage
	IsBurned   bool
}

func (q *Queries) GetValidNft(ctx context.Context, arg GetValidNftParams) (GetValidNftRow, error) {
	row := q.db.QueryRowContext(ctx, getValidNft, arg.Token, arg.Identifier)
	var i GetValidNftRow
	err := row.Scan(
		&i.Token,
		&i.Identifier,
		&i.Owner,
		&i.TokenUri,
		&i.Metadata,
		&i.IsBurned,
	)
	return i, err
}

const upsertNftV2 = `-- name: UpsertNftV2 :exec
INSERT INTO "nfts" (token, identifier, owner, token_uri, metadata, is_burned)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (token, identifier) DO UPDATE SET
    owner = $3,
    token_uri = $4,
    metadata = $5,
    is_burned = $6
WHERE nfts.block_number < $7 OR (nfts.block_number = $7 AND nfts.tx_index < $8)
`

type UpsertNftV2Params struct {
	Token       string
	Identifier  string
	Owner       string
	TokenUri    sql.NullString
	Metadata    pqtype.NullRawMessage
	IsBurned    bool
	BlockNumber string
	TxIndex     int64
}

func (q *Queries) UpsertNftV2(ctx context.Context, arg UpsertNftV2Params) error {
	_, err := q.db.ExecContext(ctx, upsertNftV2,
		arg.Token,
		arg.Identifier,
		arg.Owner,
		arg.TokenUri,
		arg.Metadata,
		arg.IsBurned,
		arg.BlockNumber,
		arg.TxIndex,
	)
	return err
}
