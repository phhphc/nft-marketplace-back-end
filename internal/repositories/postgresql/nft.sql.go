// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: nft.sql

package postgresql

import (
	"context"
	"database/sql"

	"github.com/tabbed/pqtype"
)

const getNft = `-- name: GetNft :one
SELECT n.token_id, n.contract_addr, n.owner, n.is_burned, n.metadata, l.listing_id, l.seller, l.price
FROM "nfts" n
LEFT JOIN "listings" l ON n.token_id = l.token_id AND n.contract_addr = l.contract_addr
WHERE (n.contract_addr ILIKE $1) AND (n.token_id = CAST($2 AS NUMERIC))
`

type GetNftParams struct {
	ContractAddr sql.NullString `json:"contract_addr"`
	TokenID      sql.NullString `json:"token_id"`
}

type GetNftRow struct {
	TokenID      string                `json:"token_id"`
	ContractAddr string                `json:"contract_addr"`
	Owner        string                `json:"owner"`
	IsBurned     bool                  `json:"is_burned"`
	Metadata     pqtype.NullRawMessage `json:"metadata"`
	ListingID    sql.NullString        `json:"listing_id"`
	Seller       sql.NullString        `json:"seller"`
	Price        sql.NullString        `json:"price"`
}

func (q *Queries) GetNft(ctx context.Context, arg GetNftParams) (GetNftRow, error) {
	row := q.db.QueryRowContext(ctx, getNft, arg.ContractAddr, arg.TokenID)
	var i GetNftRow
	err := row.Scan(
		&i.TokenID,
		&i.ContractAddr,
		&i.Owner,
		&i.IsBurned,
		&i.Metadata,
		&i.ListingID,
		&i.Seller,
		&i.Price,
	)
	return i, err
}

const searchValidListingNft = `-- name: SearchValidListingNft :many
SELECT n.token_id, n.contract_addr, n.owner, n.is_burned, n.metadata, l.listing_id, l.seller, l.price
FROM "nfts" n
LEFT JOIN "listings" l ON n.token_id = l.token_id AND n.contract_addr = l.contract_addr
WHERE (l.status = 'Open' OR l.listing_id IS NULL)
AND (n.contract_addr ILIKE $1 OR $1 IS NULL)
AND (n.owner ILIKE $2 OR l.seller ILIKE $2 OR $2 IS NULL)
OFFSET $3
LIMIT $4
`

type SearchValidListingNftParams struct {
	ContractAddr sql.NullString `json:"contract_addr"`
	Owner        sql.NullString `json:"owner"`
	Offset       int32          `json:"offset"`
	Limit        int32          `json:"limit"`
}

type SearchValidListingNftRow struct {
	TokenID      string                `json:"token_id"`
	ContractAddr string                `json:"contract_addr"`
	Owner        string                `json:"owner"`
	IsBurned     bool                  `json:"is_burned"`
	Metadata     pqtype.NullRawMessage `json:"metadata"`
	ListingID    sql.NullString        `json:"listing_id"`
	Seller       sql.NullString        `json:"seller"`
	Price        sql.NullString        `json:"price"`
}

func (q *Queries) SearchValidListingNft(ctx context.Context, arg SearchValidListingNftParams) ([]SearchValidListingNftRow, error) {
	rows, err := q.db.QueryContext(ctx, searchValidListingNft,
		arg.ContractAddr,
		arg.Owner,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchValidListingNftRow{}
	for rows.Next() {
		var i SearchValidListingNftRow
		if err := rows.Scan(
			&i.TokenID,
			&i.ContractAddr,
			&i.Owner,
			&i.IsBurned,
			&i.Metadata,
			&i.ListingID,
			&i.Seller,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertNft = `-- name: UpsertNft :exec
INSERT INTO "nfts" (token_id, contract_addr, owner, is_burned, metadata, block_number, tx_index)
VALUES ($1,$2,$3,$4,$5,$6,$7)
ON CONFLICT (token_id, contract_addr) DO UPDATE
SET owner=$3, is_burned=$4, metadata=$5, block_number=$6, tx_index=$7
WHERE $6 > nfts.block_number OR ($6 = nfts.block_number AND $7 > nfts.tx_index)
`

type UpsertNftParams struct {
	TokenID      string                `json:"token_id"`
	ContractAddr string                `json:"contract_addr"`
	Owner        string                `json:"owner"`
	IsBurned     bool                  `json:"is_burned"`
	Metadata     pqtype.NullRawMessage `json:"metadata"`
	BlockNumber  string                `json:"block_number"`
	TxIndex      int64                 `json:"tx_index"`
}

func (q *Queries) UpsertNft(ctx context.Context, arg UpsertNftParams) error {
	_, err := q.db.ExecContext(ctx, upsertNft,
		arg.TokenID,
		arg.ContractAddr,
		arg.Owner,
		arg.IsBurned,
		arg.Metadata,
		arg.BlockNumber,
		arg.TxIndex,
	)
	return err
}
