// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: notification.sql

package gen

import (
	"context"
	"database/sql"
)

const getNotification = `-- name: GetNotification :many
SELECT n.is_viewed, n.info, n.event_name, n.order_hash, n.address,
    e.token, e.token_id, e.quantity, e.type, e.price, e.from, e.to, e.date,
    nft.owner,
    CAST(nft.metadata ->> 'image' AS VARCHAR) AS nft_image,
	CAST(nft.metadata ->> 'name' AS VARCHAR) AS nft_name
FROM "notifications" n
JOIN "events" e ON n.event_name = e.name AND n.order_hash = e.order_hash
JOIN "nfts" nft ON e.token = nft.token AND e.token_id = CAST(nft.identifier AS varchar(78))
WHERE (n.address = $1 OR $1 IS NULL)
AND (n.is_viewed = $2 OR $2 IS NULL)
`

type GetNotificationParams struct {
	Address  sql.NullString
	IsViewed sql.NullBool
}

type GetNotificationRow struct {
	IsViewed  sql.NullBool
	Info      string
	EventName string
	OrderHash string
	Address   string
	Token     string
	TokenID   string
	Quantity  sql.NullInt32
	Type      sql.NullString
	Price     sql.NullString
	From      string
	To        sql.NullString
	Date      sql.NullTime
	Owner     string
	NftImage  string
	NftName   string
}

func (q *Queries) GetNotification(ctx context.Context, arg GetNotificationParams) ([]GetNotificationRow, error) {
	rows, err := q.query(ctx, q.getNotificationStmt, getNotification, arg.Address, arg.IsViewed)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNotificationRow{}
	for rows.Next() {
		var i GetNotificationRow
		if err := rows.Scan(
			&i.IsViewed,
			&i.Info,
			&i.EventName,
			&i.OrderHash,
			&i.Address,
			&i.Token,
			&i.TokenID,
			&i.Quantity,
			&i.Type,
			&i.Price,
			&i.From,
			&i.To,
			&i.Date,
			&i.Owner,
			&i.NftImage,
			&i.NftName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertNotification = `-- name: InsertNotification :one
INSERT INTO "notifications" ("info", "event_name", "order_hash", "address")
VALUES ($1,$2,$3,$4)
RETURNING id, info, event_name, order_hash, address, is_viewed
`

type InsertNotificationParams struct {
	Info      string
	EventName string
	OrderHash string
	Address   string
}

func (q *Queries) InsertNotification(ctx context.Context, arg InsertNotificationParams) (Notification, error) {
	row := q.queryRow(ctx, q.insertNotificationStmt, insertNotification,
		arg.Info,
		arg.EventName,
		arg.OrderHash,
		arg.Address,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Info,
		&i.EventName,
		&i.OrderHash,
		&i.Address,
		&i.IsViewed,
	)
	return i, err
}

const updateNotification = `-- name: UpdateNotification :one
UPDATE "notifications"
SET "is_viewed" = true
WHERE "event_name" = $1
AND "order_hash" = $2
RETURNING id, info, event_name, order_hash, address, is_viewed
`

type UpdateNotificationParams struct {
	EventName sql.NullString
	OrderHash sql.NullString
}

func (q *Queries) UpdateNotification(ctx context.Context, arg UpdateNotificationParams) (Notification, error) {
	row := q.queryRow(ctx, q.updateNotificationStmt, updateNotification, arg.EventName, arg.OrderHash)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.Info,
		&i.EventName,
		&i.OrderHash,
		&i.Address,
		&i.IsViewed,
	)
	return i, err
}
