// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: profile.sql

package gen

import (
	"context"
	"database/sql"

	"github.com/tabbed/pqtype"
)

const deleteProfile = `-- name: DeleteProfile :exec
DELETE FROM "profiles"
WHERE "address" = $1
`

func (q *Queries) DeleteProfile(ctx context.Context, address string) error {
	_, err := q.exec(ctx, q.deleteProfileStmt, deleteProfile, address)
	return err
}

const getOffer = `-- name: GetOffer :many
SELECT e.name, e.token, e.token_id, e.quantity,
  CAST(n.metadata ->> 'image' AS VARCHAR) AS nft_image, CAST(n.metadata ->> 'name' AS VARCHAR) AS nft_name,
	e.type, o.order_hash, e.price, n.owner, e.from, o.start_time, o.end_time,
  o.is_fulfilled, o.is_cancelled, (o.end_time < round(EXTRACT(EPOCH FROM now()))) as is_expired
FROM "events" e 
JOIN "nfts" n ON e.token = n.token AND e.token_id = CAST(n.identifier AS varchar(78))
LEFT JOIN "orders" o ON e.order_hash = o.order_hash
WHERE e.name ILIKE 'offer'
AND o.start_time <= round(EXTRACT(EPOCH FROM now()))
AND (n.owner ILIKE $1 OR $1 IS NULL)
AND (e.from ILIKE $2 OR $2 IS NULL)
`

type GetOfferParams struct {
	Owner sql.NullString
	From  sql.NullString
}

type GetOfferRow struct {
	Name        string
	Token       string
	TokenID     string
	Quantity    sql.NullInt32
	NftImage    string
	NftName     string
	Type        sql.NullString
	OrderHash   sql.NullString
	Price       sql.NullString
	Owner       string
	From        string
	StartTime   sql.NullString
	EndTime     sql.NullString
	IsFulfilled sql.NullBool
	IsCancelled sql.NullBool
	IsExpired   bool
}

func (q *Queries) GetOffer(ctx context.Context, arg GetOfferParams) ([]GetOfferRow, error) {
	rows, err := q.query(ctx, q.getOfferStmt, getOffer, arg.Owner, arg.From)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOfferRow{}
	for rows.Next() {
		var i GetOfferRow
		if err := rows.Scan(
			&i.Name,
			&i.Token,
			&i.TokenID,
			&i.Quantity,
			&i.NftImage,
			&i.NftName,
			&i.Type,
			&i.OrderHash,
			&i.Price,
			&i.Owner,
			&i.From,
			&i.StartTime,
			&i.EndTime,
			&i.IsFulfilled,
			&i.IsCancelled,
			&i.IsExpired,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfile = `-- name: GetProfile :one
SELECT "address", "username", "metadata", "signature"
FROM "profiles"
WHERE "address" = $1
LIMIT 1
`

func (q *Queries) GetProfile(ctx context.Context, address string) (Profile, error) {
	row := q.queryRow(ctx, q.getProfileStmt, getProfile, address)
	var i Profile
	err := row.Scan(
		&i.Address,
		&i.Username,
		&i.Metadata,
		&i.Signature,
	)
	return i, err
}

const upsertProfile = `-- name: UpsertProfile :one
INSERT INTO "profiles" ("address", "username", "metadata", "signature")
VALUES ($1, $2, $3, $4)
ON CONFLICT ("address") DO UPDATE SET
  "username" = $2,
  "metadata" = $3,
  "signature" = $4
RETURNING address, username, metadata, signature
`

type UpsertProfileParams struct {
	Address   string
	Username  sql.NullString
	Metadata  pqtype.NullRawMessage
	Signature string
}

func (q *Queries) UpsertProfile(ctx context.Context, arg UpsertProfileParams) (Profile, error) {
	row := q.queryRow(ctx, q.upsertProfileStmt, upsertProfile,
		arg.Address,
		arg.Username,
		arg.Metadata,
		arg.Signature,
	)
	var i Profile
	err := row.Scan(
		&i.Address,
		&i.Username,
		&i.Metadata,
		&i.Signature,
	)
	return i, err
}
