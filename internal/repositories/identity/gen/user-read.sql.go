// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: user-read.sql

package gen

import (
	"context"
	"database/sql"
)

const getAllRoles = `-- name: GetAllRoles :many
SELECT id, name FROM "roles"
`

func (q *Queries) GetAllRoles(ctx context.Context) ([]Role, error) {
	rows, err := q.query(ctx, q.getAllRolesStmt, getAllRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByAddress = `-- name: GetUserByAddress :one
SELECT public_address, nonce, is_block
FROM "users"
WHERE public_address ILIKE $1
`

func (q *Queries) GetUserByAddress(ctx context.Context, publicAddress string) (User, error) {
	row := q.queryRow(ctx, q.getUserByAddressStmt, getUserByAddress, publicAddress)
	var i User
	err := row.Scan(&i.PublicAddress, &i.Nonce, &i.IsBlock)
	return i, err
}

const getUserRoles = `-- name: GetUserRoles :many
SELECT id, name, address, role_id
FROM "roles" r
JOIN "user_roles" ur ON ur.role_id = r.id
WHERE ur.address = $1
`

type GetUserRolesRow struct {
	ID      int32
	Name    string
	Address string
	RoleID  int32
}

func (q *Queries) GetUserRoles(ctx context.Context, address string) ([]GetUserRolesRow, error) {
	rows, err := q.query(ctx, q.getUserRolesStmt, getUserRoles, address)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserRolesRow{}
	for rows.Next() {
		var i GetUserRolesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Address,
			&i.RoleID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsers = `-- name: GetUsers :many
SELECT fu.public_address, fu.nonce, r.id as role_id, r.name as role, fu.is_block
FROM (
    SELECT public_address, nonce, is_block FROM "users" u
    WHERE (u.public_address ILIKE $1 OR $1 IS NULL)
    AND (u.is_block = $2 OR $2 IS NULL)
    ORDER BY public_address ASC
    LIMIT $4
    OFFSET $3
     ) fu
LEFT JOIN "user_roles" ur on fu.public_address = ur.address
LEFT JOIN "roles" r on r.id = ur.role_id
WHERE (r.name = $5 OR $5 IS NULL)
`

type GetUsersParams struct {
	PublicAddress sql.NullString
	IsBlock       sql.NullBool
	Offset        int32
	Limit         int32
	Role          sql.NullString
}

type GetUsersRow struct {
	PublicAddress string
	Nonce         string
	RoleID        sql.NullInt32
	Role          sql.NullString
	IsBlock       bool
}

func (q *Queries) GetUsers(ctx context.Context, arg GetUsersParams) ([]GetUsersRow, error) {
	rows, err := q.query(ctx, q.getUsersStmt, getUsers,
		arg.PublicAddress,
		arg.IsBlock,
		arg.Offset,
		arg.Limit,
		arg.Role,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersRow{}
	for rows.Next() {
		var i GetUsersRow
		if err := rows.Scan(
			&i.PublicAddress,
			&i.Nonce,
			&i.RoleID,
			&i.Role,
			&i.IsBlock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
