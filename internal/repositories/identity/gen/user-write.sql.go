// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: user-write.sql

package gen

import (
	"context"
)

const deleteUserRole = `-- name: DeleteUserRole :exec
DELETE FROM "user_roles"
WHERE address = $1 AND role_id = $2
`

type DeleteUserRoleParams struct {
	Address string
	RoleID  int32
}

func (q *Queries) DeleteUserRole(ctx context.Context, arg DeleteUserRoleParams) error {
	_, err := q.exec(ctx, q.deleteUserRoleStmt, deleteUserRole, arg.Address, arg.RoleID)
	return err
}

const insertUser = `-- name: InsertUser :one
INSERT INTO "users" (public_address, nonce)
VALUES ($1, $2)
RETURNING public_address, nonce, is_block
`

type InsertUserParams struct {
	PublicAddress string
	Nonce         string
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) (User, error) {
	row := q.queryRow(ctx, q.insertUserStmt, insertUser, arg.PublicAddress, arg.Nonce)
	var i User
	err := row.Scan(&i.PublicAddress, &i.Nonce, &i.IsBlock)
	return i, err
}

const insertUserRole = `-- name: InsertUserRole :one
INSERT INTO "user_roles" (address, role_id)
VALUES ($1, $2)
RETURNING address, role_id
`

type InsertUserRoleParams struct {
	Address string
	RoleID  int32
}

func (q *Queries) InsertUserRole(ctx context.Context, arg InsertUserRoleParams) (UserRole, error) {
	row := q.queryRow(ctx, q.insertUserRoleStmt, insertUserRole, arg.Address, arg.RoleID)
	var i UserRole
	err := row.Scan(&i.Address, &i.RoleID)
	return i, err
}

const updateNonce = `-- name: UpdateNonce :one
UPDATE "users"
SET nonce = $1
WHERE public_address ILIKE $2
RETURNING public_address, nonce, is_block
`

type UpdateNonceParams struct {
	Nonce         string
	PublicAddress string
}

func (q *Queries) UpdateNonce(ctx context.Context, arg UpdateNonceParams) (User, error) {
	row := q.queryRow(ctx, q.updateNonceStmt, updateNonce, arg.Nonce, arg.PublicAddress)
	var i User
	err := row.Scan(&i.PublicAddress, &i.Nonce, &i.IsBlock)
	return i, err
}

const updateUserBlockState = `-- name: UpdateUserBlockState :one
UPDATE "users"
SET is_block = $1
WHERE public_address ILIKE $2
RETURNING public_address, nonce, is_block
`

type UpdateUserBlockStateParams struct {
	IsBlock       bool
	PublicAddress string
}

func (q *Queries) UpdateUserBlockState(ctx context.Context, arg UpdateUserBlockStateParams) (User, error) {
	row := q.queryRow(ctx, q.updateUserBlockStateStmt, updateUserBlockState, arg.IsBlock, arg.PublicAddress)
	var i User
	err := row.Scan(&i.PublicAddress, &i.Nonce, &i.IsBlock)
	return i, err
}
