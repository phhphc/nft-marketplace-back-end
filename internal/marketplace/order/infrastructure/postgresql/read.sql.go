// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: read.sql

package postgresql

import (
	"context"
	"database/sql"
)

const getOrder = `-- name: GetOrder :one
SELECT
    o.order_hash,
    o.offerer,
    o.zone,
    o.is_cancelled,
    o.is_validated,
    o.signature,
    o.order_type,
    o.start_time,
    o.end_time,
    o.salt,
    o.counter,
    o.zone,
    o.zone_hash,
    o.created_at,
    o.modified_at
FROM marketplace_order o
WHERE o.order_hash = $1
`

type GetOrderRow struct {
	OrderHash   string
	Offerer     string
	Zone        sql.NullString
	IsCancelled bool
	IsValidated bool
	Signature   sql.NullString
	OrderType   string
	StartTime   string
	EndTime     string
	Salt        string
	Counter     string
	Zone_2      sql.NullString
	ZoneHash    sql.NullString
	CreatedAt   sql.NullTime
	ModifiedAt  sql.NullTime
}

func (q *Queries) GetOrder(ctx context.Context, orderHash string) (GetOrderRow, error) {
	row := q.db.QueryRowContext(ctx, getOrder, orderHash)
	var i GetOrderRow
	err := row.Scan(
		&i.OrderHash,
		&i.Offerer,
		&i.Zone,
		&i.IsCancelled,
		&i.IsValidated,
		&i.Signature,
		&i.OrderType,
		&i.StartTime,
		&i.EndTime,
		&i.Salt,
		&i.Counter,
		&i.Zone_2,
		&i.ZoneHash,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}

const getOrderConsideration = `-- name: GetOrderConsideration :many
SELECT
    cons.type_number,
    cons.token_address,
    cons.token_id,
    cons.start_amount,
    cons.end_amount,
    cons.recipient
FROM marketplace_order_consideration cons
WHERE cons.order_hash = $1
`

type GetOrderConsiderationRow struct {
	TypeNumber   string
	TokenAddress string
	TokenID      string
	StartAmount  string
	EndAmount    string
	Recipient    string
}

func (q *Queries) GetOrderConsideration(ctx context.Context, orderHash string) ([]GetOrderConsiderationRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderConsideration, orderHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderConsiderationRow{}
	for rows.Next() {
		var i GetOrderConsiderationRow
		if err := rows.Scan(
			&i.TypeNumber,
			&i.TokenAddress,
			&i.TokenID,
			&i.StartAmount,
			&i.EndAmount,
			&i.Recipient,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderHashByConsiderationItem = `-- name: GetOrderHashByConsiderationItem :many
SELECT DISTINCT
    c.order_hash,
    o.created_at
FROM marketplace_order_consideration c
LEFT JOIN (
    SELECT created_at, order_hash, is_cancelled FROM marketplace_order
    ) o
ON c.order_hash = o.order_hash
WHERE c.token_address = $1
AND c.token_id = $2
AND (is_cancelled = $3 OR is_cancelled IS NULL)
ORDER BY o.created_at DESC
`

type GetOrderHashByConsiderationItemParams struct {
	TokenAddress string
	TokenID      string
	IsCancelled  sql.NullBool
}

type GetOrderHashByConsiderationItemRow struct {
	OrderHash string
	CreatedAt sql.NullTime
}

func (q *Queries) GetOrderHashByConsiderationItem(ctx context.Context, arg GetOrderHashByConsiderationItemParams) ([]GetOrderHashByConsiderationItemRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderHashByConsiderationItem, arg.TokenAddress, arg.TokenID, arg.IsCancelled)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderHashByConsiderationItemRow{}
	for rows.Next() {
		var i GetOrderHashByConsiderationItemRow
		if err := rows.Scan(&i.OrderHash, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderHashByOfferItem = `-- name: GetOrderHashByOfferItem :many
SELECT DISTINCT
    offer.order_hash,
    o.created_at
FROM marketplace_order_offer offer
LEFT JOIN (
    SELECT created_at, order_hash, is_cancelled FROM marketplace_order
    ) o
ON offer.order_hash = o.order_hash
WHERE offer.token_address = $1
AND offer.token_id = $2
AND (is_cancelled = $3 OR is_cancelled IS NULL)
ORDER BY o.created_at DESC
`

type GetOrderHashByOfferItemParams struct {
	TokenAddress string
	TokenID      string
	IsCancelled  sql.NullBool
}

type GetOrderHashByOfferItemRow struct {
	OrderHash string
	CreatedAt sql.NullTime
}

func (q *Queries) GetOrderHashByOfferItem(ctx context.Context, arg GetOrderHashByOfferItemParams) ([]GetOrderHashByOfferItemRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderHashByOfferItem, arg.TokenAddress, arg.TokenID, arg.IsCancelled)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderHashByOfferItemRow{}
	for rows.Next() {
		var i GetOrderHashByOfferItemRow
		if err := rows.Scan(&i.OrderHash, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderOffer = `-- name: GetOrderOffer :many
SELECT
    offer.type_number,
    offer.token_address,
    offer.token_id,
    offer.start_amount,
    offer.end_amount
FROM marketplace_order_offer offer
WHERE offer.order_hash = $1
`

type GetOrderOfferRow struct {
	TypeNumber   string
	TokenAddress string
	TokenID      string
	StartAmount  string
	EndAmount    string
}

func (q *Queries) GetOrderOffer(ctx context.Context, orderHash string) ([]GetOrderOfferRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderOffer, orderHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOrderOfferRow{}
	for rows.Next() {
		var i GetOrderOfferRow
		if err := rows.Scan(
			&i.TypeNumber,
			&i.TokenAddress,
			&i.TokenID,
			&i.StartAmount,
			&i.EndAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
